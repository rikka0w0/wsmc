// Load common properties
Properties mergedProperties = new Properties();
mergedProperties.load(new FileInputStream("$project.rootDir/../common.properties"));
// Loader-specific gradle.properties takes priority
mergedProperties.load(new FileInputStream("$project.rootDir/gradle.properties"));
mergedProperties.each { prop -> project.ext.set(prop.key, prop.value); }

project.ext.set("mergedProperties", mergedProperties)
project.ext.minecraft_version_range = '[' + project.minecraft_version_min + ', ' + project.minecraft_version_max + ')';

// Load secrete tokens
defaultIfNotExist('curseforgeApiToken', System.getenv("CURSEFORGE_TOKEN"))
defaultIfNotExist('modrinthApiToken', System.getenv("MODRINTH_TOKEN"))

def defaultIfNotExist(propertyName, defaultValue) {
	if (!project.hasProperty(propertyName) || project.getProperty(propertyName) == null) {
		project.ext.set(propertyName, defaultValue);
	}
}

/**
 * @param version a version string that looks like "1.21" or "1.20.4"
 * @return a string array that contains exactly 3 strings
 */
def normalizeVersion(versionString) {
	def parts = versionString.split('\\.');
	parts = parts.size() < 3 ? parts + ["0"] * (3 - parts.size()) : parts.take(3);
	return parts.collect { it.toInteger() };
}

/**
 * @param version1 a string array that contains exactly 3 strings
 * @param version2 a string array that contains exactly 3 strings
 * @return 1 if version1>version2, 0 if both are equal, -1 if version1<version2
 */
def compareVersions(version1, version2) {
	for (int i = 0; i < 3; i++) {
		if (version1[i] < version2[i]) return -1;
		if (version1[i] > version2[i]) return 1;
	}
	return 0
}

println 'The following Minecraft versions will be DECLARED as supported:'
def lowerBound = normalizeVersion(project.minecraft_version_min);
def upperBound = normalizeVersion(project.minecraft_version_max);
def knownMcVers = mergedProperties.minecraft_versions_declared.split(',').collect { it.trim() };
def minSupportedVersion = null;
def maxSupportedVersion = null;
project.ext.minecraft_versions_supported = [];
for (int i = 0; i < knownMcVers.size(); i++) {
	def versionString = knownMcVers[i];
	def version = normalizeVersion(versionString);

	// Check if version is within the range
	if (compareVersions(version, lowerBound) >= 0 && compareVersions(version, upperBound) < 0) {
		project.ext.minecraft_versions_supported.add(versionString);
		println(versionString);

		if (minSupportedVersion == null || compareVersions(version, normalizeVersion(minSupportedVersion)) < 0) {
			minSupportedVersion = versionString;
		}

		if (maxSupportedVersion == null || compareVersions(version, normalizeVersion(maxSupportedVersion)) > 0) {
			maxSupportedVersion = versionString;
		}
	}
}

// Prefix of the release file
def version_prefix = (minSupportedVersion == maxSupportedVersion) ? minSupportedVersion : "${minSupportedVersion}-${maxSupportedVersion}";
project.ext.publish_prefix = version_prefix + '-' + project.ext.mod_version;

// Define a custom task to dump properties
task exportProperties {
	outputs.file file("$buildDir/info/properties.txt")
	doLast {
		outputs.files.singleFile.withWriter { writer -> {
			mergedProperties.each { key, value -> writer.writeLine("${key}=${value}"); }
			writer.writeLine("minecraft_version_range=${project.minecraft_version_range}");
			writer.writeLine("minecraft_versions_supported=${project.minecraft_versions_supported.join(', ')}");
			writer.writeLine("publish_prefix=${project.publish_prefix}");
		}}
	}
}
